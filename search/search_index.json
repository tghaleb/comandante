{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Comandante A CLI toolkit including an option parser and some helper commands to make life easier. Features Easy to use command line option parser . Supports four option types : Switches Options Repeating Switches Repeating Options Automatic addition of help (active by default ). User actions can be attached to commands/options. Argument count checking. Customizable modes of failure : Exit with message Raise exception A cleaner which allows for custom cleanup functions on exits or exceptions. tempfiles and directories that will automatically be cleaned on exit. A ConfigSignleton class that simplifies loading config from yaml files. A helper providing: error messages warning messages debugging messages assertions yaml reader/writer gzip file reader/writer and more ... Colorized backtrace messages for exceptions . Helper functions for bitwise operations . Installation Add the dependency to your shard.yml : dependencies: comandante: github: tghaleb/comandante Run shards install Examples In Commandante project directory: make examples ./examples/prog1 -h ./examples/prog2 --help ./examples/prog1-config --debug ./examples/prog1-config.yaml Take a look at the code in examples/ and optionally in spec/ . Usage require \"comandante\" OptParser OptParser can be used to parse arguments for interfaces with simple arguments as well as those that have sub commands. For a very basic CLI create a new OptParser . @opts = OptParser.new(NAME, LABEL, arguments_string: \"FILE\", arguments_range: 1..1) arguments_range for argument count checking. Add an option, unless you specify the option type it is a Swtich @opts.append_option( OptParser::OptionConfig.new( name: \"debug\", label: \"debug mode\", simple_action: OptParser::OptProc.new { |v| Cleaner.debug = v.as(Bool) } )) @opts.append_option( OptParser::OptionConfig.new( name: \"verbose\", label: \"verbose mode\", simple_action: OptParser::OptProc.new { |v| Cleaner.verbose = v.as(Bool) } )) The simple_action takes a proc that sets debug mode. Another option that you can use is action which takes a class derived from OptionAction . Use it when simple_action is not enough. @opts.parse Helper.debug_inspect(@opts.args) Helper.debug_inspect(@opts.options) debug_inspect will display debug messages if the user uses the --debug switch. For a full example take a look at examples/ There is also debug and debug_pretty macros, which are wrappers around the above but will not be included when compiled in --release mode. These are the ones to use when maximum performance is required, to avoid any overhead of the debug calls. Just require: require \"comandante/macros\" and include Macros where you want to use them. For subcommands you create a class derived from CommandAction . class Eval < CommandAction def run( global_opts : OptionsHash, opts : OptionsHash, args : Array(String) ) : Nil Helper.debug_inspect global_opts Helper.debug_inspect opts Helper.debug_inspect args opts[\"src\"].as(Array(String)).each do |f| File.open(f) do |io| \"will read \" + f end end end end Create configuration for the sub command EVAL_OPTS = CommandConfig.new( name: \"eval\", label: \"Evaluates some sources.\", description: <<-E.to_s, Will evaluate something. And can accept repeating --src options Example: #{NAME} eval --src one --src two E action: Commands::Eval.new, arguments_range: 0..0, options: [ OptionConfig.new( name: \"src\", short: \"s\", label: \"src of file(s) to eval.\", argument_string: \"FILE\", option_type: OptionStyle::RepeatingOption, ), ], ) Here the action is the command object. For the option src we are using a RepeatingOption . Aappend the configuration to the parser. opts.append(EVAL_OPTS) For a complete example take a look at examples/ Cleaner You wrap your code in a Cleaner.run Cleaner.run do |x| opts.parse tempfile = Cleaner.tempfile do_stuff(temfile) tempdir = Cleaner.tempdir do_stuff(tempdir) raise \"something wrong happend\" end Cleaner.run will remove created tempfiles and temp directories on exiting the block. It will also catch any raised exceptions and exit printing the error message, or, if in debug mode, it will print a colorized backtrace. For temp files and directories you will probably want to use a block, to make sure files are removed as soon as you're done with them. Cleaner.run do |x| Cleaner.tempfile do |file| # do something with file end # file will be removed end You can register cleanup procs that will be run on block exit, or when a Cleaner explicit exit is called. Cleaner.register -> { puts \"will do cleanups\" } In cases you want to exit with an error, or just exit cleanly, you can run if File.file? file Cleaner.exit_success else Cleaner.exit_failure(\"Failed to create file\") end Both will run a cleanup job before they exit, running any registered cleaners in addition to removing tempfiles and temp directories. Helper # printing messages Helper.debug_msg(\"Will print this in debug mode\" Helper.debug_inspect(@opts) Helper.put_error(\"Something went wrong\") Helper.put_verbose(\"Creating files\") # running commands Helper.run(\"touch newfile\") # asserts Helper.assert(x < 5, \"Not in range\") Helper.assert_file(file) Helper.assert_directory(dir) # reading files @config = Helper.read_yaml(file) @config = Helper.parse_yaml(str, context_str) Helper.read_gzip(file) do |line| puts line end s = Helper.read_gzip(path) # Create a directory with a verbose option Helper.mkdir(dir, verbose: true) # digests for files/strings puts Helper.file_md5sum(path) puts Helper.file_sha1sum(path) puts Helper.string_sha256sum(\"test\") puts Helper.string_sha512sum(\"test\") # Times a job and prints time it took Helper.timer { long_job } Bits x = 5.to_u16 y = 12.to_u64 Bits.set_bits(x, [1, 3, 7, 8]) # test if a bit is set do_something if Bits.bit_set?(3, y) z = Bits.get_bits(y, from: 2, count 3) z = Bits.popcount_bits(y, from: 1, count 3) puts Bits.bits_to_string(y) Bits.loop_over_set_bits(x) do |i| puts \"bit #{i} is set\" end # store int as uint and vice versa, for example if you want # to save uints in an sqlite database. m = bits.store_as_int(x) u = bits.store_as_uint(m) see spec/ Config A ConfigSingleton that simplifies loading config from a yaml file. You use the included macro config_type , for example: class Config < ConfigSingleton config_type(MyConfig) do name : String = \"foo\" age : Int32 = 150 end ... Which creates accessors on both the instance and on the Config module. And you can pass a yaml config file to initialize the instance like so: Config.load_config(\"config.yaml\") puts Config.to_yaml puts Config.name puts Config.age ... You can also add a validator for the config data, def self.validate if self.age > 200 self.exit_error(\"bad age #{self.age}\") end end Which you can call by calling Config.validate You can also create complex types that are classes and nest config, just make sure to create them with sub_config_type see examples, sub_config_type(URLConfig) do ... end Take a look at the code in examples/ .","title":"Home"},{"location":"#comandante","text":"A CLI toolkit including an option parser and some helper commands to make life easier.","title":"Comandante"},{"location":"#features","text":"Easy to use command line option parser . Supports four option types : Switches Options Repeating Switches Repeating Options Automatic addition of help (active by default ). User actions can be attached to commands/options. Argument count checking. Customizable modes of failure : Exit with message Raise exception A cleaner which allows for custom cleanup functions on exits or exceptions. tempfiles and directories that will automatically be cleaned on exit. A ConfigSignleton class that simplifies loading config from yaml files. A helper providing: error messages warning messages debugging messages assertions yaml reader/writer gzip file reader/writer and more ... Colorized backtrace messages for exceptions . Helper functions for bitwise operations .","title":"Features"},{"location":"#installation","text":"Add the dependency to your shard.yml : dependencies: comandante: github: tghaleb/comandante Run shards install","title":"Installation"},{"location":"#examples","text":"In Commandante project directory: make examples ./examples/prog1 -h ./examples/prog2 --help ./examples/prog1-config --debug ./examples/prog1-config.yaml Take a look at the code in examples/ and optionally in spec/ .","title":"Examples"},{"location":"#usage","text":"require \"comandante\"","title":"Usage"},{"location":"#optparser","text":"OptParser can be used to parse arguments for interfaces with simple arguments as well as those that have sub commands. For a very basic CLI create a new OptParser . @opts = OptParser.new(NAME, LABEL, arguments_string: \"FILE\", arguments_range: 1..1) arguments_range for argument count checking. Add an option, unless you specify the option type it is a Swtich @opts.append_option( OptParser::OptionConfig.new( name: \"debug\", label: \"debug mode\", simple_action: OptParser::OptProc.new { |v| Cleaner.debug = v.as(Bool) } )) @opts.append_option( OptParser::OptionConfig.new( name: \"verbose\", label: \"verbose mode\", simple_action: OptParser::OptProc.new { |v| Cleaner.verbose = v.as(Bool) } )) The simple_action takes a proc that sets debug mode. Another option that you can use is action which takes a class derived from OptionAction . Use it when simple_action is not enough. @opts.parse Helper.debug_inspect(@opts.args) Helper.debug_inspect(@opts.options) debug_inspect will display debug messages if the user uses the --debug switch. For a full example take a look at examples/ There is also debug and debug_pretty macros, which are wrappers around the above but will not be included when compiled in --release mode. These are the ones to use when maximum performance is required, to avoid any overhead of the debug calls. Just require: require \"comandante/macros\" and include Macros where you want to use them. For subcommands you create a class derived from CommandAction . class Eval < CommandAction def run( global_opts : OptionsHash, opts : OptionsHash, args : Array(String) ) : Nil Helper.debug_inspect global_opts Helper.debug_inspect opts Helper.debug_inspect args opts[\"src\"].as(Array(String)).each do |f| File.open(f) do |io| \"will read \" + f end end end end Create configuration for the sub command EVAL_OPTS = CommandConfig.new( name: \"eval\", label: \"Evaluates some sources.\", description: <<-E.to_s, Will evaluate something. And can accept repeating --src options Example: #{NAME} eval --src one --src two E action: Commands::Eval.new, arguments_range: 0..0, options: [ OptionConfig.new( name: \"src\", short: \"s\", label: \"src of file(s) to eval.\", argument_string: \"FILE\", option_type: OptionStyle::RepeatingOption, ), ], ) Here the action is the command object. For the option src we are using a RepeatingOption . Aappend the configuration to the parser. opts.append(EVAL_OPTS) For a complete example take a look at examples/","title":"OptParser"},{"location":"#cleaner","text":"You wrap your code in a Cleaner.run Cleaner.run do |x| opts.parse tempfile = Cleaner.tempfile do_stuff(temfile) tempdir = Cleaner.tempdir do_stuff(tempdir) raise \"something wrong happend\" end Cleaner.run will remove created tempfiles and temp directories on exiting the block. It will also catch any raised exceptions and exit printing the error message, or, if in debug mode, it will print a colorized backtrace. For temp files and directories you will probably want to use a block, to make sure files are removed as soon as you're done with them. Cleaner.run do |x| Cleaner.tempfile do |file| # do something with file end # file will be removed end You can register cleanup procs that will be run on block exit, or when a Cleaner explicit exit is called. Cleaner.register -> { puts \"will do cleanups\" } In cases you want to exit with an error, or just exit cleanly, you can run if File.file? file Cleaner.exit_success else Cleaner.exit_failure(\"Failed to create file\") end Both will run a cleanup job before they exit, running any registered cleaners in addition to removing tempfiles and temp directories.","title":"Cleaner"},{"location":"#helper","text":"# printing messages Helper.debug_msg(\"Will print this in debug mode\" Helper.debug_inspect(@opts) Helper.put_error(\"Something went wrong\") Helper.put_verbose(\"Creating files\") # running commands Helper.run(\"touch newfile\") # asserts Helper.assert(x < 5, \"Not in range\") Helper.assert_file(file) Helper.assert_directory(dir) # reading files @config = Helper.read_yaml(file) @config = Helper.parse_yaml(str, context_str) Helper.read_gzip(file) do |line| puts line end s = Helper.read_gzip(path) # Create a directory with a verbose option Helper.mkdir(dir, verbose: true) # digests for files/strings puts Helper.file_md5sum(path) puts Helper.file_sha1sum(path) puts Helper.string_sha256sum(\"test\") puts Helper.string_sha512sum(\"test\") # Times a job and prints time it took Helper.timer { long_job }","title":"Helper"},{"location":"#bits","text":"x = 5.to_u16 y = 12.to_u64 Bits.set_bits(x, [1, 3, 7, 8]) # test if a bit is set do_something if Bits.bit_set?(3, y) z = Bits.get_bits(y, from: 2, count 3) z = Bits.popcount_bits(y, from: 1, count 3) puts Bits.bits_to_string(y) Bits.loop_over_set_bits(x) do |i| puts \"bit #{i} is set\" end # store int as uint and vice versa, for example if you want # to save uints in an sqlite database. m = bits.store_as_int(x) u = bits.store_as_uint(m) see spec/","title":"Bits"},{"location":"#config","text":"A ConfigSingleton that simplifies loading config from a yaml file. You use the included macro config_type , for example: class Config < ConfigSingleton config_type(MyConfig) do name : String = \"foo\" age : Int32 = 150 end ... Which creates accessors on both the instance and on the Config module. And you can pass a yaml config file to initialize the instance like so: Config.load_config(\"config.yaml\") puts Config.to_yaml puts Config.name puts Config.age ... You can also add a validator for the config data, def self.validate if self.age > 200 self.exit_error(\"bad age #{self.age}\") end end Which you can call by calling Config.validate You can also create complex types that are classes and nest config, just make sure to create them with sub_config_type see examples, sub_config_type(URLConfig) do ... end Take a look at the code in examples/ .","title":"Config"},{"location":"bits/","text":"module Comandante::Bits Some bitwise helper functions Constants BIT_MASKS = { 8 => BitMasks ( UInt8 ) . get_masks , 16 => BitMasks ( UInt16 ) . get_masks , 32 => BitMasks ( UInt32 ) . get_masks , 64 => BitMasks ( UInt64 ) . get_masks , 128 => BitMasks ( UInt128 ) . get_masks } Bit masks for every bit position for a UInt type MASKS = { 8 => { 0 . to_u8 , 1 . to_u8 , UInt8 :: MAX }, 16 => { 0 . to_u16 , 1 . to_u16 , UInt16 :: MAX }, 32 => { 0 . to_u32 , 1 . to_u32 , UInt32 :: MAX }, 64 => { 0 . to_u64 , 1 . to_u64 , UInt64 :: MAX }, 128 => { 0 . to_u128 , 1 . to_u128 , UInt128 :: MAX }} Masks for each size of UInt of 0,1, and MAX Class methods .bit_set? ( pos , uint ) : Bool Tests if a bit is set View source .bits_to_string ( uint ) : String Returns binary representation as String View source .get_bits ( uint , from : Int32 , count : Int32 ) Returns n bits from position Example To get a new uint with only count bits from given position x = get_bits(u, from: 3, count 2]) View source .loop_over_bits ( uint , & ) : Nil Loop over bits of a bitmap (UInt types) View source .loop_over_set_bits ( uint , & ) : Nil Loop over set bits of a bitmap (UInt types) View source .popcount_bits ( uint , from , count ) : Int32 Popcount n bits View source .set_bits ( uint , a : Array ( Int8 )) Sets bits on Uint Types Example To set bits 1,7 and 8 set_bits(x, [1, 7, 8]) View source .set_bits ( uint , a : Array ( Int16 )) Sets bits on Uint Types Example To set bits 1,7 and 8 set_bits(x, [1, 7, 8]) View source .set_bits ( uint , a : Array ( Int32 )) Sets bits on Uint Types Example To set bits 1,7 and 8 set_bits(x, [1, 7, 8]) View source .set_bits ( uint , a : Array ( Int64 )) Sets bits on Uint Types Example To set bits 1,7 and 8 set_bits(x, [1, 7, 8]) View source .set_bits ( uint , a : Array ( Int128 )) Sets bits on Uint Types Example To set bits 1,7 and 8 set_bits(x, [1, 7, 8]) View source .store_as_int ( uint : UInt8 ) : Int8 Stores uint in int so we can serialize/store in places where uint is not supported View source .store_as_int ( uint : UInt16 ) : Int16 Stores uint in int so we can serialize/store in places where uint is not supported View source .store_as_int ( uint : UInt32 ) : Int32 Stores uint in int so we can serialize/store in places where uint is not supported View source .store_as_int ( uint : UInt64 ) : Int64 Stores uint in int so we can serialize/store in places where uint is not supported View source .store_as_int ( uint : UInt128 ) : Int128 Stores uint in int so we can serialize/store in places where uint is not supported View source .store_as_uint ( int : Int8 ) : UInt8 Stores int as uint for conversion serialize/store in places where uint is not supported View source .store_as_uint ( int : Int16 ) : UInt16 Stores int as uint for conversion serialize/store in places where uint is not supported View source .store_as_uint ( int : Int32 ) : UInt32 Stores int as uint for conversion serialize/store in places where uint is not supported View source .store_as_uint ( int : Int64 ) : UInt64 Stores int as uint for conversion serialize/store in places where uint is not supported View source .store_as_uint ( int : Int128 ) : UInt128 Stores int as uint for conversion serialize/store in places where uint is not supported View source Macros type_bits ( t ) Returns the number of bits in a type View source","title":"Bits"},{"location":"bits/#Comandante::Bits","text":"Some bitwise helper functions","title":"Bits"},{"location":"bits/#Comandante::Bits-constants","text":"","title":"Constants"},{"location":"bits/#Comandante::Bits::BIT_MASKS","text":"Bit masks for every bit position for a UInt type","title":"BIT_MASKS"},{"location":"bits/#Comandante::Bits::MASKS","text":"Masks for each size of UInt of 0,1, and MAX","title":"MASKS"},{"location":"bits/#Comandante::Bits-class-methods","text":"","title":"Class methods"},{"location":"bits/#Comandante::Bits.bit_set?(pos,uint)","text":"Tests if a bit is set View source","title":".bit_set?"},{"location":"bits/#Comandante::Bits.bits_to_string(uint)","text":"Returns binary representation as String View source","title":".bits_to_string"},{"location":"bits/#Comandante::Bits.get_bits(uint,from,count)","text":"Returns n bits from position Example To get a new uint with only count bits from given position x = get_bits(u, from: 3, count 2]) View source","title":".get_bits"},{"location":"bits/#Comandante::Bits.loop_over_bits(uint,&)","text":"Loop over bits of a bitmap (UInt types) View source","title":".loop_over_bits"},{"location":"bits/#Comandante::Bits.loop_over_set_bits(uint,&)","text":"Loop over set bits of a bitmap (UInt types) View source","title":".loop_over_set_bits"},{"location":"bits/#Comandante::Bits.popcount_bits(uint,from,count)","text":"Popcount n bits View source","title":".popcount_bits"},{"location":"bits/#Comandante::Bits.set_bits(uint,a)","text":"Sets bits on Uint Types Example To set bits 1,7 and 8 set_bits(x, [1, 7, 8]) View source","title":".set_bits"},{"location":"bits/#Comandante::Bits.set_bits(uint,a)","text":"Sets bits on Uint Types Example To set bits 1,7 and 8 set_bits(x, [1, 7, 8]) View source","title":".set_bits"},{"location":"bits/#Comandante::Bits.set_bits(uint,a)","text":"Sets bits on Uint Types Example To set bits 1,7 and 8 set_bits(x, [1, 7, 8]) View source","title":".set_bits"},{"location":"bits/#Comandante::Bits.set_bits(uint,a)","text":"Sets bits on Uint Types Example To set bits 1,7 and 8 set_bits(x, [1, 7, 8]) View source","title":".set_bits"},{"location":"bits/#Comandante::Bits.set_bits(uint,a)","text":"Sets bits on Uint Types Example To set bits 1,7 and 8 set_bits(x, [1, 7, 8]) View source","title":".set_bits"},{"location":"bits/#Comandante::Bits.store_as_int(uint)","text":"Stores uint in int so we can serialize/store in places where uint is not supported View source","title":".store_as_int"},{"location":"bits/#Comandante::Bits.store_as_int(uint)","text":"Stores uint in int so we can serialize/store in places where uint is not supported View source","title":".store_as_int"},{"location":"bits/#Comandante::Bits.store_as_int(uint)","text":"Stores uint in int so we can serialize/store in places where uint is not supported View source","title":".store_as_int"},{"location":"bits/#Comandante::Bits.store_as_int(uint)","text":"Stores uint in int so we can serialize/store in places where uint is not supported View source","title":".store_as_int"},{"location":"bits/#Comandante::Bits.store_as_int(uint)","text":"Stores uint in int so we can serialize/store in places where uint is not supported View source","title":".store_as_int"},{"location":"bits/#Comandante::Bits.store_as_uint(int)","text":"Stores int as uint for conversion serialize/store in places where uint is not supported View source","title":".store_as_uint"},{"location":"bits/#Comandante::Bits.store_as_uint(int)","text":"Stores int as uint for conversion serialize/store in places where uint is not supported View source","title":".store_as_uint"},{"location":"bits/#Comandante::Bits.store_as_uint(int)","text":"Stores int as uint for conversion serialize/store in places where uint is not supported View source","title":".store_as_uint"},{"location":"bits/#Comandante::Bits.store_as_uint(int)","text":"Stores int as uint for conversion serialize/store in places where uint is not supported View source","title":".store_as_uint"},{"location":"bits/#Comandante::Bits.store_as_uint(int)","text":"Stores int as uint for conversion serialize/store in places where uint is not supported View source","title":".store_as_uint"},{"location":"bits/#Comandante::Bits-macros","text":"","title":"Macros"},{"location":"bits/#Comandante::Bits:type_bits(t)","text":"Returns the number of bits in a type View source","title":"type_bits"},{"location":"cleaner/","text":"module Comandante::Cleaner Extended modules Comandante::Cleaner Class methods .debug Debug Mode, you can use an action to set this with a global --debug option View source .debug= ( debug ) Debug Mode, you can use an action to set this with a global --debug option View source .exit_on_pipe_error Exit on pipe error, sometimes you to exit on pipe errors View source .exit_on_pipe_error= ( exit_on_pipe_error ) Exit on pipe error, sometimes you to exit on pipe errors View source .failure_behavior The desired failure_behavior, see FailureMode View source .failure_behavior= ( failure_behavior ) The desired failure_behavior, see FailureMode View source .verbose View source .verbose= ( verbose ) View source Methods #cleanup : Nil Runs cleanup manually before end of block or from outside it. will run user cleanup procs first, then remove any tempfiles or tempdirs. View source #exit_failure ( msg : String , status = 1 ) : Nil Will exit or raise exception with a message in accordance with failure_behavior . Will run cleanup first. View source #exit_success ( msg : String = \"\" , status = 0 ) : Nil Will exit with a message. Will run cleanup first. View source #register ( proc : SimpleProc ) : Nil Register a cleanup proc to be executed on exit from Cleanup::run block. Example: register ->{ my_cleaner; puts \"cleanup done!\" } View source #run : Nil Runs a block with cleanup afterwards. You should wrap your app.run inside Examples: Cleaner.run do app.run end Will capture exceptions and run user cleanup function at end of block. View source #tempdir ( name = File . tempname ) : Dir Create a tempdir that will be removed on exit as long as you are running inside a run block View source #tempdir ( name = File . tempname , & ) : Nil Create a tempdir that will be removed on exit from block View source #tempfile : File Create a tempfile that will be removed on exit as long as you are running inside a run block View source #tempfile : Nil Create a tempfile that will be removed on exit from block View source","title":"Cleaner"},{"location":"cleaner/#Comandante::Cleaner","text":"","title":"Cleaner"},{"location":"cleaner/#Comandante::Cleaner-class-methods","text":"","title":"Class methods"},{"location":"cleaner/#Comandante::Cleaner.debug","text":"Debug Mode, you can use an action to set this with a global --debug option View source","title":".debug"},{"location":"cleaner/#Comandante::Cleaner.debug=(debug)","text":"Debug Mode, you can use an action to set this with a global --debug option View source","title":".debug="},{"location":"cleaner/#Comandante::Cleaner.exit_on_pipe_error","text":"Exit on pipe error, sometimes you to exit on pipe errors View source","title":".exit_on_pipe_error"},{"location":"cleaner/#Comandante::Cleaner.exit_on_pipe_error=(exit_on_pipe_error)","text":"Exit on pipe error, sometimes you to exit on pipe errors View source","title":".exit_on_pipe_error="},{"location":"cleaner/#Comandante::Cleaner.failure_behavior","text":"The desired failure_behavior, see FailureMode View source","title":".failure_behavior"},{"location":"cleaner/#Comandante::Cleaner.failure_behavior=(failure_behavior)","text":"The desired failure_behavior, see FailureMode View source","title":".failure_behavior="},{"location":"cleaner/#Comandante::Cleaner.verbose","text":"View source","title":".verbose"},{"location":"cleaner/#Comandante::Cleaner.verbose=(verbose)","text":"View source","title":".verbose="},{"location":"cleaner/#Comandante::Cleaner-methods","text":"","title":"Methods"},{"location":"cleaner/#Comandante::Cleaner#cleanup","text":"Runs cleanup manually before end of block or from outside it. will run user cleanup procs first, then remove any tempfiles or tempdirs. View source","title":"#cleanup"},{"location":"cleaner/#Comandante::Cleaner#exit_failure(msg,status)","text":"Will exit or raise exception with a message in accordance with failure_behavior . Will run cleanup first. View source","title":"#exit_failure"},{"location":"cleaner/#Comandante::Cleaner#exit_success(msg,status)","text":"Will exit with a message. Will run cleanup first. View source","title":"#exit_success"},{"location":"cleaner/#Comandante::Cleaner#register(proc)","text":"Register a cleanup proc to be executed on exit from Cleanup::run block. Example: register ->{ my_cleaner; puts \"cleanup done!\" } View source","title":"#register"},{"location":"cleaner/#Comandante::Cleaner#run","text":"Runs a block with cleanup afterwards. You should wrap your app.run inside Examples: Cleaner.run do app.run end Will capture exceptions and run user cleanup function at end of block. View source","title":"#run"},{"location":"cleaner/#Comandante::Cleaner#tempdir(name)","text":"Create a tempdir that will be removed on exit as long as you are running inside a run block View source","title":"#tempdir"},{"location":"cleaner/#Comandante::Cleaner#tempfile","text":"Create a tempfile that will be removed on exit as long as you are running inside a run block View source","title":"#tempfile"},{"location":"cleaner_types/","text":"alias Comandante::Cleaner::SimpleProc Alias definition -> Nil enum Comandante::Cleaner::FailureMode Failure Mode types Members EXIT = 0 EXCEPTION = 1 Methods #exception? View source #exit? View source","title":"Cleaner Types"},{"location":"cleaner_types/#Comandante::Cleaner::SimpleProc","text":"","title":"SimpleProc"},{"location":"cleaner_types/#Comandante::Cleaner::FailureMode","text":"Failure Mode types","title":"FailureMode"},{"location":"cleaner_types/#Comandante::Cleaner::FailureMode-members","text":"","title":"Members"},{"location":"cleaner_types/#Comandante::Cleaner::FailureMode::EXIT","text":"","title":"EXIT"},{"location":"cleaner_types/#Comandante::Cleaner::FailureMode::EXCEPTION","text":"","title":"EXCEPTION"},{"location":"cleaner_types/#Comandante::Cleaner::FailureMode-methods","text":"","title":"Methods"},{"location":"cleaner_types/#Comandante::Cleaner::FailureMode#exception?","text":"View source","title":"#exception?"},{"location":"cleaner_types/#Comandante::Cleaner::FailureMode#exit?","text":"View source","title":"#exit?"},{"location":"comandante/","text":"module Comandante Direct including types Comandante::ConfigSingleton Constants VERSION = \"0.1.7\"","title":"Comandante"},{"location":"comandante/#Comandante","text":"","title":"Comandante"},{"location":"comandante/#Comandante-constants","text":"","title":"Constants"},{"location":"comandante/#Comandante::VERSION","text":"","title":"VERSION"},{"location":"config_singleton/","text":"abstract class Comandante::ConfigSingleton inherits Reference Create your config class from this Example class Config < ConfigSingleton config_type(MyConfig) do name : String = \"foo\" age : Int32 = 150 end ... end if you intend to use nested types define one or more sub_config_type sub_config_type(URLConfig) do scheme : String = \"https\" no_proxy : Bool = false end config_type(ServerConfig) do urls : Hash(String, URLConfig) = Hash(String, URLConfig).new end Included modules Comandante Comandante::Macros Class methods .load_config ( file ) Used to load/read config file Example Config.load_config(ARGV[0]) View source .to_yaml Dumps to yaml Example Config.to_yaml View source Macros config_type defines a config type and accessors of its properties on the singleton class as well as on @config, also defines a load_config View source sub_config_type test this View source","title":"ConfigSigleton"},{"location":"config_singleton/#Comandante::ConfigSingleton","text":"Create your config class from this Example class Config < ConfigSingleton config_type(MyConfig) do name : String = \"foo\" age : Int32 = 150 end ... end if you intend to use nested types define one or more sub_config_type sub_config_type(URLConfig) do scheme : String = \"https\" no_proxy : Bool = false end config_type(ServerConfig) do urls : Hash(String, URLConfig) = Hash(String, URLConfig).new end","title":"ConfigSingleton"},{"location":"config_singleton/#Comandante::ConfigSingleton-class-methods","text":"","title":"Class methods"},{"location":"config_singleton/#Comandante::ConfigSingleton.load_config(file)","text":"Used to load/read config file Example Config.load_config(ARGV[0]) View source","title":".load_config"},{"location":"config_singleton/#Comandante::ConfigSingleton.to_yaml","text":"Dumps to yaml Example Config.to_yaml View source","title":".to_yaml"},{"location":"config_singleton/#Comandante::ConfigSingleton-macros","text":"","title":"Macros"},{"location":"config_singleton/#Comandante::ConfigSingleton:config_type(klass,&)","text":"defines a config type and accessors of its properties on the singleton class as well as on @config, also defines a load_config View source","title":"config_type"},{"location":"config_singleton/#Comandante::ConfigSingleton:sub_config_type(klass,&)","text":"test this View source","title":"sub_config_type"},{"location":"helper/","text":"module Comandante::Helper::YamlTo(T) A from_yaml wrapper that exits/raises on failure Example x = YamlTo(Array(Int32)).load(\"[1,2,3]\", \":config\") Class methods .load ( s , context = \"\" ) : T View source module Comandante::Helper Some helper functions Constants EMPTY_STRING_ARRAY = Array ( String ) . new Class methods .assert ( cond , msg ) : Nil Asserts a condition, depending on Cleaner will either exit with message or raise an error Example: assert(value > 0, \"Expecting a value > 0\") View source .assert_directory ( dir ) : Nil Asserts that a directory exists View source .assert_file ( file ) : Nil Asserts that a file exists View source .debug_inspect ( val , context = \"\" ) Prints a colorized inspect of val if Cleaner is in debug mode Example: debug_inspect(@opts, context: \"@opts\") debug_inspect({test: x == y}) debug_inspect([\"one\", \"two\"]) View source .file_md5sum ( path ) : String Returns md5 digest for file View source .file_sha1sum ( path ) : String Returns sha1 digest for file View source .file_sha256sum ( path ) : String Returns sha256 digest for file View source .file_sha512sum ( path ) : String Returns sha512 digest for file View source .mkdir ( dir : String , verbose = false ) mkdir with verbose option View source .parse_yaml ( str , context = \"\" ) : YAML :: Any Parses yaml string and fails with message, context is used in error messages View source .put_debug ( msg , pref = \"Debug: \" ) Prints a debug message if Cleaner is in debug mode View source .put_error ( msg , pref = \"Error: \" ) Prints an error message to STDERR View source .put_verbose ( msg ) Prints a message to STDERR if in verbose mode View source .put_warning ( msg , pref = \"Warning: \" ) Prints a warning message to STDERR View source .read_gzip ( path , & ) : Nil Reads gziped file line by line read_gzip(path) { |line| puts line } View source .read_gzip ( path ) : String Reads gziped file into a string View source .read_yaml ( file : String ) : YAML :: Any Parses yaml from file and fails with message View source .run ( cmd , args = EMPTY_STRING_ARRAY , msg = \"cmd failed\" ) : Nil Runs a command using system and raises if command fails View source .string_md5sum ( path ) : String Returns md5 digest for string View source .string_sha1sum ( path ) : String Returns sha1 digest for string View source .string_sha256sum ( path ) : String Returns sha256 digest for string View source .string_sha512sum ( path ) : String Returns sha512 digest for string View source .string_to_file ( str , file ) : Nil Writes String to a file View source .timer Timer for a block of commands, prints time at the end Examples timer { do_something } View source .write_binary_file ( file : String , data : Bytes ) Writes Bytes to a file View source .write_gzip ( str , path ) : Nil Writes gziped file from a string View source","title":"Helper"},{"location":"helper/#Comandante::Helper::YamlTo","text":"A from_yaml wrapper that exits/raises on failure Example x = YamlTo(Array(Int32)).load(\"[1,2,3]\", \":config\")","title":"YamlTo"},{"location":"helper/#Comandante::Helper::YamlTo-class-methods","text":"","title":"Class methods"},{"location":"helper/#Comandante::Helper::YamlTo.load(s,context)","text":"View source","title":".load"},{"location":"helper/#Comandante::Helper","text":"Some helper functions","title":"Helper"},{"location":"helper/#Comandante::Helper-constants","text":"","title":"Constants"},{"location":"helper/#Comandante::Helper::EMPTY_STRING_ARRAY","text":"","title":"EMPTY_STRING_ARRAY"},{"location":"helper/#Comandante::Helper-class-methods","text":"","title":"Class methods"},{"location":"helper/#Comandante::Helper.assert(cond,msg)","text":"Asserts a condition, depending on Cleaner will either exit with message or raise an error Example: assert(value > 0, \"Expecting a value > 0\") View source","title":".assert"},{"location":"helper/#Comandante::Helper.assert_directory(dir)","text":"Asserts that a directory exists View source","title":".assert_directory"},{"location":"helper/#Comandante::Helper.assert_file(file)","text":"Asserts that a file exists View source","title":".assert_file"},{"location":"helper/#Comandante::Helper.debug_inspect(val,context)","text":"Prints a colorized inspect of val if Cleaner is in debug mode Example: debug_inspect(@opts, context: \"@opts\") debug_inspect({test: x == y}) debug_inspect([\"one\", \"two\"]) View source","title":".debug_inspect"},{"location":"helper/#Comandante::Helper.file_md5sum(path)","text":"Returns md5 digest for file View source","title":".file_md5sum"},{"location":"helper/#Comandante::Helper.file_sha1sum(path)","text":"Returns sha1 digest for file View source","title":".file_sha1sum"},{"location":"helper/#Comandante::Helper.file_sha256sum(path)","text":"Returns sha256 digest for file View source","title":".file_sha256sum"},{"location":"helper/#Comandante::Helper.file_sha512sum(path)","text":"Returns sha512 digest for file View source","title":".file_sha512sum"},{"location":"helper/#Comandante::Helper.mkdir(dir,verbose)","text":"mkdir with verbose option View source","title":".mkdir"},{"location":"helper/#Comandante::Helper.parse_yaml(str,context)","text":"Parses yaml string and fails with message, context is used in error messages View source","title":".parse_yaml"},{"location":"helper/#Comandante::Helper.put_debug(msg,pref)","text":"Prints a debug message if Cleaner is in debug mode View source","title":".put_debug"},{"location":"helper/#Comandante::Helper.put_error(msg,pref)","text":"Prints an error message to STDERR View source","title":".put_error"},{"location":"helper/#Comandante::Helper.put_verbose(msg)","text":"Prints a message to STDERR if in verbose mode View source","title":".put_verbose"},{"location":"helper/#Comandante::Helper.put_warning(msg,pref)","text":"Prints a warning message to STDERR View source","title":".put_warning"},{"location":"helper/#Comandante::Helper.read_gzip(path,&)","text":"Reads gziped file line by line read_gzip(path) { |line| puts line } View source","title":".read_gzip"},{"location":"helper/#Comandante::Helper.read_yaml(file)","text":"Parses yaml from file and fails with message View source","title":".read_yaml"},{"location":"helper/#Comandante::Helper.run(cmd,args,msg)","text":"Runs a command using system and raises if command fails View source","title":".run"},{"location":"helper/#Comandante::Helper.string_md5sum(path)","text":"Returns md5 digest for string View source","title":".string_md5sum"},{"location":"helper/#Comandante::Helper.string_sha1sum(path)","text":"Returns sha1 digest for string View source","title":".string_sha1sum"},{"location":"helper/#Comandante::Helper.string_sha256sum(path)","text":"Returns sha256 digest for string View source","title":".string_sha256sum"},{"location":"helper/#Comandante::Helper.string_sha512sum(path)","text":"Returns sha512 digest for string View source","title":".string_sha512sum"},{"location":"helper/#Comandante::Helper.string_to_file(str,file)","text":"Writes String to a file View source","title":".string_to_file"},{"location":"helper/#Comandante::Helper.timer","text":"Timer for a block of commands, prints time at the end Examples timer { do_something } View source","title":".timer"},{"location":"helper/#Comandante::Helper.write_binary_file(file,data)","text":"Writes Bytes to a file View source","title":".write_binary_file"},{"location":"helper/#Comandante::Helper.write_gzip(str,path)","text":"Writes gziped file from a string View source","title":".write_gzip"},{"location":"macros/","text":"module Comandante::Macros Direct including types Comandante::ConfigSingleton Macros as_singleton use inside a class to make it a singleton View source debug ( msg ) debug macro that doesn't get evaluated in :release mode View source debug ( msg , context ) View source debug_pretty ( data ) debug macro that doesn't get evaluated in :release mode View source debug_pretty ( data , context ) View source","title":"Macros"},{"location":"macros/#Comandante::Macros","text":"","title":"Macros"},{"location":"macros/#Comandante::Macros-macros","text":"","title":"Macros"},{"location":"macros/#Comandante::Macros:as_singleton","text":"use inside a class to make it a singleton View source","title":"as_singleton"},{"location":"macros/#Comandante::Macros:debug(msg)","text":"debug macro that doesn't get evaluated in :release mode View source","title":"debug"},{"location":"macros/#Comandante::Macros:debug_pretty(data)","text":"debug macro that doesn't get evaluated in :release mode View source","title":"debug_pretty"},{"location":"opt_parser/","text":"class Comandante::OptParser inherits Reference Included modules Comandante::OptParserTypes Constants COLOR_OFF_OPT = OptionConfig . new ( name : \"no-color\" , short : \"C\" , label : \"color mode off.\" , action : ColorOffAction . new ) DEBUG_OPT = OptionConfig . new ( name : \"debug\" , short : \"D\" , label : \"debug mode.\" , action : DebugAction . new ) Built-ins ERROR_MSGS = { invalid_option : \"invalid option '%s'!\" , bad_command : \"bad sub_command '%s'!\" , wrong_argument_count : \"wrong argument count!\" , option_requires_value : \"option --%s requires a value\" } Todo cleanups for this file :nodoc: ROOT_ID = \"/\" ID for the main command, used internally VERBOSE_OPT = OptionConfig . new ( name : \"verbose\" , short : \"v\" , label : \"verbose mode.\" , simple_action : OptParser :: OptProc . new do | v | Cleaner . verbose = true end ) VERSION_OPT = OptionConfig . new ( name : \"version\" , label : \"display version and exit.\" , action : VersionAction . new ) Constructors .new ( name , label , description = \"\" , arguments_string = \"\" , arguments_range = 0 .. MAX_ARGS ) Creates the parser for the program. At lease a name and label are required. Examples: For a simple program that will not use subcommands, and accepts 1 argument opts = OptParser.new(NAME, LABEL, DESC, argument_string: \"FILE\", argument_range: 1..1) For a program that will have subcommands opts = OptParser.new(NAME, LABEL, DESC) View source Class methods .assert_arg_count ( args : Array ( String ), range : Range ( Int32 , Int32 )) Asserts argument count is in range, used internally, no need to call this directly View source .assert_option_value ( opt , value ) Asserts option has a value set or a default, used internally, no need to call this directly View source .version View source .version= ( val : String ) View source Methods #append ( cmd : CommandConfig ) Appends Configuration for a subcommand, including its options. Examples: Adding a subcommand opts.append(EVAL_OPTS) where EVAL_OPTS is a OptParserTypes::CommandConfig View source #append_option ( opt : OptionConfig , id = ROOT_ID ) Appends configuration for an option, id is the name/id of the subcommand, when not given option is added to the main/root command. Examples: Adding to main command opts.append_option(DEBUG_OPT) where DEBUG_OPT is an OptParserTypes::OptionConfig Although you can also use this method to add options to subcommands, prefered way is to use append and configure subcommands with all options that way. View source #args Arguments Parsed View source #auto_help Controls to add or not to add a help option to command+subcommands View source #auto_help= ( auto_help : Bool ) Controls to add or not to add a help option to command+subcommands View source #commands_str The header to user for subcommands (defaults are usually fine) View source #commands_str= ( commands_str : String ) The header to user for subcommands (defaults are usually fine) View source #max_width Controls Maximum text width View source #max_width= ( max_width : Int32 ) Controls Maximum text width View source #options ( id = ROOT_ID ) Options Parsed View source #options_str The header to use for options (defaults are usually fine) View source #options_str= ( options_str : String ) The header to use for options (defaults are usually fine) View source #parse ( args = ARGV , id = ROOT_ID ) Do the actual parsing, called after all subcommands and options are added to OptParser object. Will call any action associated with subcommands and options If you have no subcommands then you'll probably want to call .options and .args to get the options and arguments passed to the program. View source #print_help ( id = ROOT_ID ) Is called automatically but just in case you want to call it manually View source","title":"OptParser"},{"location":"opt_parser/#Comandante::OptParser","text":"","title":"OptParser"},{"location":"opt_parser/#Comandante::OptParser-constants","text":"","title":"Constants"},{"location":"opt_parser/#Comandante::OptParser::COLOR_OFF_OPT","text":"","title":"COLOR_OFF_OPT"},{"location":"opt_parser/#Comandante::OptParser::DEBUG_OPT","text":"Built-ins","title":"DEBUG_OPT"},{"location":"opt_parser/#Comandante::OptParser::ERROR_MSGS","text":"Todo cleanups for this file :nodoc:","title":"ERROR_MSGS"},{"location":"opt_parser/#Comandante::OptParser::ROOT_ID","text":"ID for the main command, used internally","title":"ROOT_ID"},{"location":"opt_parser/#Comandante::OptParser::VERBOSE_OPT","text":"","title":"VERBOSE_OPT"},{"location":"opt_parser/#Comandante::OptParser::VERSION_OPT","text":"","title":"VERSION_OPT"},{"location":"opt_parser/#Comandante::OptParser-constructors","text":"","title":"Constructors"},{"location":"opt_parser/#Comandante::OptParser.new(name,label,description,arguments_string,arguments_range)","text":"Creates the parser for the program. At lease a name and label are required. Examples: For a simple program that will not use subcommands, and accepts 1 argument opts = OptParser.new(NAME, LABEL, DESC, argument_string: \"FILE\", argument_range: 1..1) For a program that will have subcommands opts = OptParser.new(NAME, LABEL, DESC) View source","title":".new"},{"location":"opt_parser/#Comandante::OptParser-class-methods","text":"","title":"Class methods"},{"location":"opt_parser/#Comandante::OptParser.assert_arg_count(args,range)","text":"Asserts argument count is in range, used internally, no need to call this directly View source","title":".assert_arg_count"},{"location":"opt_parser/#Comandante::OptParser.assert_option_value(opt,value)","text":"Asserts option has a value set or a default, used internally, no need to call this directly View source","title":".assert_option_value"},{"location":"opt_parser/#Comandante::OptParser.version","text":"View source","title":".version"},{"location":"opt_parser/#Comandante::OptParser.version=(val)","text":"View source","title":".version="},{"location":"opt_parser/#Comandante::OptParser-methods","text":"","title":"Methods"},{"location":"opt_parser/#Comandante::OptParser#append(cmd)","text":"Appends Configuration for a subcommand, including its options. Examples: Adding a subcommand opts.append(EVAL_OPTS) where EVAL_OPTS is a OptParserTypes::CommandConfig View source","title":"#append"},{"location":"opt_parser/#Comandante::OptParser#append_option(opt,id)","text":"Appends configuration for an option, id is the name/id of the subcommand, when not given option is added to the main/root command. Examples: Adding to main command opts.append_option(DEBUG_OPT) where DEBUG_OPT is an OptParserTypes::OptionConfig Although you can also use this method to add options to subcommands, prefered way is to use append and configure subcommands with all options that way. View source","title":"#append_option"},{"location":"opt_parser/#Comandante::OptParser#args","text":"Arguments Parsed View source","title":"#args"},{"location":"opt_parser/#Comandante::OptParser#auto_help","text":"Controls to add or not to add a help option to command+subcommands View source","title":"#auto_help"},{"location":"opt_parser/#Comandante::OptParser#auto_help=(auto_help)","text":"Controls to add or not to add a help option to command+subcommands View source","title":"#auto_help="},{"location":"opt_parser/#Comandante::OptParser#commands_str","text":"The header to user for subcommands (defaults are usually fine) View source","title":"#commands_str"},{"location":"opt_parser/#Comandante::OptParser#commands_str=(commands_str)","text":"The header to user for subcommands (defaults are usually fine) View source","title":"#commands_str="},{"location":"opt_parser/#Comandante::OptParser#max_width","text":"Controls Maximum text width View source","title":"#max_width"},{"location":"opt_parser/#Comandante::OptParser#max_width=(max_width)","text":"Controls Maximum text width View source","title":"#max_width="},{"location":"opt_parser/#Comandante::OptParser#options(id)","text":"Options Parsed View source","title":"#options"},{"location":"opt_parser/#Comandante::OptParser#options_str","text":"The header to use for options (defaults are usually fine) View source","title":"#options_str"},{"location":"opt_parser/#Comandante::OptParser#options_str=(options_str)","text":"The header to use for options (defaults are usually fine) View source","title":"#options_str="},{"location":"opt_parser/#Comandante::OptParser#parse(args,id)","text":"Do the actual parsing, called after all subcommands and options are added to OptParser object. Will call any action associated with subcommands and options If you have no subcommands then you'll probably want to call .options and .args to get the options and arguments passed to the program. View source","title":"#parse"},{"location":"opt_parser/#Comandante::OptParser#print_help(id)","text":"Is called automatically but just in case you want to call it manually View source","title":"#print_help"},{"location":"opt_parser_types/","text":"module Comandante::OptParserTypes Common Types used inside Comandante Direct including types Comandante::OptParser Constants EMPTY_ARGS = Array ( String ) . new ( size : 0 , value : \"\" ) Just in case an empty args array is needed MAX_ARGS = 256 Default maximum number of program argument, you can however set any number in argument configuration range. Macros new_option_action inside yield you can use parser, id, and value View source enum Comandante::OptParserTypes::OptionStyle Available Types for Options Members Switch = 0 Option = 1 RepeatingSwitch = 2 RepeatingOption = 3 Methods #option? View source #repeating_option? View source #repeating_switch? View source #switch? View source alias Comandante::OptParserTypes::OptionValue Alias definition Array ( String ) | Bool | Float64 | Int32 | String alias Comandante::OptParserTypes::OptionsHash Alias definition Hash ( String , Array ( String ) | Bool | Float64 | Int32 | String ) abstract class Comandante::OptParserTypes::CommandAction inherits Reference A base class for Command Actions Direct known subclasses Comandante::OptParserTypes::NullCommandAction Methods abstract #run ( global_opts : OptionsHash , opts : OptionsHash , args : Array ( String )) : Nil View source abstract class Comandante::OptParserTypes::OptionAction inherits Reference A base class for Option Actions Direct known subclasses Comandante::OptParser::ColorOffAction Comandante::OptParser::DebugAction Comandante::OptParser::VersionAction Comandante::OptParserTypes::NullOptionAction Methods abstract #run ( parser : OptParser , id : String , value : OptionValue ) : OptionValue View source struct Comandante::OptParserTypes::CommandConfig inherits Struct Constructors .new ( name : String , label : String , description : String = \"\" , arguments_string : String = \"\" , arguments_range : Range ( Int32 , Int32 ) = 0 .. MAX_ARGS , action : CommandAction = NullCommandAction . new , options : Array ( OptionConfig ) = Array ( OptionConfig ) . new , _id : String = \"\" ) View source Methods #_id : String #action : CommandAction #arguments_range : Range ( Int32 , Int32 ) #arguments_string : String #clone View source #copy_with ( name _name = @name , label _label = @label , description _description = @description , arguments_string _arguments_string = @arguments_string , arguments_range _arguments_range = @arguments_range , action _action = @action , options _options = @options , _id __id = @_id ) View source #description : String #id View source #label : String #name : String #options : Array ( OptionConfig ) struct Comandante::OptParserTypes::OptionConfig inherits Struct Constructors .new ( name : String , label : String , short : String = \"\" , option_type : OptionStyle = OptionStyle :: Switch , default : OptionValue = \"\" , argument_string : String = \"ARG\" , simple_action : OptProc = -> ( s : OptionValue ) do end , action : OptionAction = NullOptionAction . new ) View source Methods #action : OptionAction #argument_string : String #clone View source #copy_with ( name _name = @name , label _label = @label , short _short = @short , option_type _option_type = @option_type , default _default = @default , argument_string _argument_string = @argument_string , simple_action _simple_action = @simple_action , action _action = @action ) View source #default : OptionValue #label : String #name : String #option_type : OptionStyle #short : String #simple_action : OptProc","title":"OptParser Types"},{"location":"opt_parser_types/#Comandante::OptParserTypes","text":"Common Types used inside Comandante","title":"OptParserTypes"},{"location":"opt_parser_types/#Comandante::OptParserTypes-constants","text":"","title":"Constants"},{"location":"opt_parser_types/#Comandante::OptParserTypes::EMPTY_ARGS","text":"Just in case an empty args array is needed","title":"EMPTY_ARGS"},{"location":"opt_parser_types/#Comandante::OptParserTypes::MAX_ARGS","text":"Default maximum number of program argument, you can however set any number in argument configuration range.","title":"MAX_ARGS"},{"location":"opt_parser_types/#Comandante::OptParserTypes-macros","text":"","title":"Macros"},{"location":"opt_parser_types/#Comandante::OptParserTypes:new_option_action(klass,&)","text":"inside yield you can use parser, id, and value View source","title":"new_option_action"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle","text":"Available Types for Options","title":"OptionStyle"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle-members","text":"","title":"Members"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle::Switch","text":"","title":"Switch"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle::Option","text":"","title":"Option"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle::RepeatingSwitch","text":"","title":"RepeatingSwitch"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle::RepeatingOption","text":"","title":"RepeatingOption"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle-methods","text":"","title":"Methods"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle#option?","text":"View source","title":"#option?"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle#repeating_option?","text":"View source","title":"#repeating_option?"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle#repeating_switch?","text":"View source","title":"#repeating_switch?"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionStyle#switch?","text":"View source","title":"#switch?"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionValue","text":"","title":"OptionValue"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionsHash","text":"","title":"OptionsHash"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandAction","text":"A base class for Command Actions","title":"CommandAction"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandAction-methods","text":"","title":"Methods"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandAction#run(global_opts,opts,args)","text":"View source","title":"#run"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionAction","text":"A base class for Option Actions","title":"OptionAction"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionAction-methods","text":"","title":"Methods"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionAction#run(parser,id,value)","text":"View source","title":"#run"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig","text":"","title":"CommandConfig"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig-constructors","text":"","title":"Constructors"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig.new(name,label,description,arguments_string,arguments_range,action,options,_id)","text":"View source","title":".new"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig-methods","text":"","title":"Methods"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#_id","text":"","title":"#_id"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#action","text":"","title":"#action"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#arguments_range","text":"","title":"#arguments_range"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#arguments_string","text":"","title":"#arguments_string"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#clone","text":"View source","title":"#clone"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#copy_with(name,label,description,arguments_string,arguments_range,action,options,_id)","text":"View source","title":"#copy_with"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#description","text":"","title":"#description"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#id","text":"View source","title":"#id"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#label","text":"","title":"#label"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#name","text":"","title":"#name"},{"location":"opt_parser_types/#Comandante::OptParserTypes::CommandConfig#options","text":"","title":"#options"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig","text":"","title":"OptionConfig"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig-constructors","text":"","title":"Constructors"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig.new(name,label,short,option_type,default,argument_string,simple_action,action)","text":"View source","title":".new"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig-methods","text":"","title":"Methods"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig#action","text":"","title":"#action"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig#argument_string","text":"","title":"#argument_string"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig#clone","text":"View source","title":"#clone"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig#copy_with(name,label,short,option_type,default,argument_string,simple_action,action)","text":"View source","title":"#copy_with"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig#default","text":"","title":"#default"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig#label","text":"","title":"#label"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig#name","text":"","title":"#name"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig#option_type","text":"","title":"#option_type"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig#short","text":"","title":"#short"},{"location":"opt_parser_types/#Comandante::OptParserTypes::OptionConfig#simple_action","text":"","title":"#simple_action"},{"location":"other/","text":"Other class Exception inherits Reference Represents errors that occur during application execution. Exception and its descendants are used to communicate between raise and rescue statements in begin ... end blocks. Exception objects carry information about the exception \u2013 its type (the exception\u2019s class name), an optional descriptive string, and optional traceback information. Exception subclasses may add additional information. Methods #formatted_backtrace : String Adds a colorized backtrace to exceptions View source","title":"Other"},{"location":"other/#other","text":"","title":"Other"},{"location":"other/#Exception","text":"Represents errors that occur during application execution. Exception and its descendants are used to communicate between raise and rescue statements in begin ... end blocks. Exception objects carry information about the exception \u2013 its type (the exception\u2019s class name), an optional descriptive string, and optional traceback information. Exception subclasses may add additional information.","title":"Exception"},{"location":"other/#Exception-methods","text":"","title":"Methods"},{"location":"other/#Exception#formatted_backtrace","text":"Adds a colorized backtrace to exceptions View source","title":"#formatted_backtrace"}]}